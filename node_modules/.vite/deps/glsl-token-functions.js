import {
  __commonJS
} from "./chunk-VUNV25KB.js";

// node_modules/glsl-token-functions/index.js
var require_glsl_token_functions = __commonJS({
  "node_modules/glsl-token-functions/index.js"(exports, module) {
    module.exports = functions;
    function functions(tokens) {
      var returnType = null;
      var defnName = null;
      var braceDepth = 0;
      var braceStart = 0;
      var defnStart = 0;
      var argFinish = 0;
      var argStart = 0;
      var output = [];
      var i, j, token;
      for (i = 0, j; i < tokens.length; i++) {
        token = tokens[i];
        if (token.data === "{") {
          if (braceDepth && braceDepth++) continue;
          j = findPrevious(i, findOp(")"), findOp());
          if (j < 0) continue;
          argFinish = j;
          j = findPrevious(j, findOp("("), findOp(")"));
          if (j < 0) continue;
          argStart = j;
          j = findPrevious(j, findGlyph);
          if (j < 0) continue;
          if (tokens[j].type !== "ident") continue;
          defnName = tokens[j].data;
          j = findPrevious(j, findGlyph);
          if (j < 0) continue;
          braceDepth = 1;
          braceStart = i;
          returnType = tokens[j].data;
          defnStart = j;
          var k = findPrevious(j, findGlyph);
          switch (tokens[k] && tokens[k].data) {
            case "lowp":
            case "highp":
            case "mediump":
              defnStart = k;
          }
        } else if (braceDepth && token.data === "}") {
          if (--braceDepth) continue;
          output.push({
            name: defnName,
            type: returnType,
            body: [braceStart + 1, i],
            args: [argStart, argFinish + 1],
            outer: [defnStart, i + 1]
          });
        }
      }
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        if (token.data === ";") {
          j = findPrevious(i, findOp(")"), findOp());
          if (j < 0) continue;
          argFinish = j;
          j = findPrevious(j, findOp("("), findOp(")"));
          if (j < 0) continue;
          argStart = j;
          j = findPrevious(j, findGlyph);
          if (j < 0) continue;
          if (tokens[j].type !== "ident") continue;
          defnName = tokens[j].data;
          j = findPrevious(j, findGlyph);
          if (j < 0) continue;
          if (tokens[j].type === "operator") continue;
          if (tokens[j].data === "return") continue;
          returnType = tokens[j].data;
          output.push({
            name: defnName,
            type: returnType,
            body: false,
            args: [argStart, argFinish + 1],
            outer: [j, i + 1]
          });
        }
      }
      return output.sort(function(a, b) {
        return a.outer[0] - b.outer[0];
      });
      function findPrevious(start, match, bail) {
        for (var i2 = start - 1; i2 >= 0; i2--) {
          if (match(tokens[i2])) return i2;
          if (bail && bail(tokens[i2])) return -1;
        }
        return -1;
      }
    }
    function findOp(data) {
      return function(token) {
        return token.type === "operator" && (!data || token.data === data);
      };
    }
    function findGlyph(token) {
      return token.type !== "whitespace";
    }
  }
});
export default require_glsl_token_functions();
//# sourceMappingURL=glsl-token-functions.js.map
