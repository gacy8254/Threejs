{
  "version": 3,
  "sources": ["../../glsl-token-functions/index.js"],
  "sourcesContent": ["module.exports = functions\n\nfunction functions (tokens) {\n  var returnType = null\n  var defnName = null\n  var braceDepth = 0\n  var braceStart = 0\n  var defnStart = 0\n  var argFinish = 0\n  var argStart = 0\n  var output = []\n  var i, j, token\n\n  // The following loop detects functions with bodies of any type,\n  // including structs. e.g.\n  // void main() {...}\n  // vec4 fn(vec3 a) {...}\n  // Ray3 fn(vec3 ro, vec3 rd) {...}\n  for (i = 0, j; i < tokens.length; i++) {\n    token = tokens[i]\n    if (token.data === '{') {\n      // If already in a function, keep track of opening braces\n      if (braceDepth && braceDepth++) continue\n\n      // Stepping backwards from the closing brace, find the end\n      // of the arguments list. There should only be whitespace on\n      // the way there.\n      j = findPrevious(i, findOp(')'), findOp())\n      if (j < 0) continue\n      argFinish = j\n\n      // Step backwards to find the beginning of the arguments list. If there's\n      // a nested paranthesis in there, then it's definitely not a function.\n      j = findPrevious(j, findOp('('), findOp(')'))\n      if (j < 0) continue\n      argStart = j\n\n      // Continue stepping backwards past any whitespace to find the\n      // function name. If the token isn't an identifier then it's not a\n      // function so we bail\n      j = findPrevious(j, findGlyph)\n      if (j < 0) continue\n      if (tokens[j].type !== 'ident') continue\n      defnName = tokens[j].data\n\n      // The next non-whitespace token should be the return type of\n      // the function\n      j = findPrevious(j, findGlyph)\n      if (j < 0) continue\n\n      braceDepth = 1\n      braceStart = i\n      returnType = tokens[j].data\n      defnStart = j\n\n      // There are cases when a function definition includes a\n      // precision qualifier, e.g. highp float random();\n      // So we backtrack one extra step to check if that's the\n      // case, and handle it :)\n      var k = findPrevious(j, findGlyph)\n      switch (tokens[k] && tokens[k].data) {\n        case 'lowp':\n        case 'highp':\n        case 'mediump':\n          defnStart = k\n      }\n    } else\n    if (braceDepth && token.data === '}') {\n      if (--braceDepth) continue\n\n      output.push({\n        name: defnName,\n        type: returnType,\n        body: [braceStart + 1, i],\n        args: [argStart, argFinish + 1],\n        outer: [defnStart, i + 1]\n      })\n    }\n  }\n\n  // This loop is for handling the edge case of functions defined\n  // without a body. Generally, this body is defined later in the file.\n  // void main();\n  // vec2 doModel(vec3 p);\n  // Note the replacement of curly braces with a semicolon.\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i]\n    if (token.data === ';') {\n      // Like before, we start from a semicolon and find the\n      // bounds of the argument list to find the function name\n      j = findPrevious(i, findOp(')'), findOp())\n      if (j < 0) continue\n      argFinish = j\n      j = findPrevious(j, findOp('('), findOp(')'))\n      if (j < 0) continue\n      argStart = j\n      j = findPrevious(j, findGlyph)\n      if (j < 0) continue\n      if (tokens[j].type !== 'ident') continue\n      defnName = tokens[j].data\n\n      // Try and find an ident or builtin character, which should be\n      // our return type. If so, it'll be the very first preceding glyph.\n      j = findPrevious(j, findGlyph)\n      if (j < 0) continue\n      if (tokens[j].type === 'operator') continue\n      if (tokens[j].data === 'return') continue\n      returnType = tokens[j].data\n\n      output.push({\n        name: defnName,\n        type: returnType,\n        body: false,\n        args: [argStart, argFinish + 1],\n        outer: [j, i + 1]\n      })\n    }\n  }\n\n  return output.sort(function (a, b) {\n    return a.outer[0] - b.outer[0]\n  })\n\n  function findPrevious (start, match, bail) {\n    for (var i = start - 1; i >= 0; i--) {\n      if (match(tokens[i])) return i\n      if (bail && bail(tokens[i])) return -1\n    }\n\n    return -1\n  }\n}\n\nfunction findOp (data) {\n  return function (token) {\n    return token.type === 'operator' && (!data || token.data === data)\n  }\n}\n\nfunction findGlyph (token) {\n  return token.type !== 'whitespace'\n}\n"],
  "mappings": ";;;;;AAAA;AAAA;AAAA,WAAO,UAAU;AAEjB,aAAS,UAAW,QAAQ;AAC1B,UAAI,aAAa;AACjB,UAAI,WAAW;AACf,UAAI,aAAa;AACjB,UAAI,aAAa;AACjB,UAAI,YAAY;AAChB,UAAI,YAAY;AAChB,UAAI,WAAW;AACf,UAAI,SAAS,CAAC;AACd,UAAI,GAAG,GAAG;AAOV,WAAK,IAAI,GAAG,GAAG,IAAI,OAAO,QAAQ,KAAK;AACrC,gBAAQ,OAAO,CAAC;AAChB,YAAI,MAAM,SAAS,KAAK;AAEtB,cAAI,cAAc,aAAc;AAKhC,cAAI,aAAa,GAAG,OAAO,GAAG,GAAG,OAAO,CAAC;AACzC,cAAI,IAAI,EAAG;AACX,sBAAY;AAIZ,cAAI,aAAa,GAAG,OAAO,GAAG,GAAG,OAAO,GAAG,CAAC;AAC5C,cAAI,IAAI,EAAG;AACX,qBAAW;AAKX,cAAI,aAAa,GAAG,SAAS;AAC7B,cAAI,IAAI,EAAG;AACX,cAAI,OAAO,CAAC,EAAE,SAAS,QAAS;AAChC,qBAAW,OAAO,CAAC,EAAE;AAIrB,cAAI,aAAa,GAAG,SAAS;AAC7B,cAAI,IAAI,EAAG;AAEX,uBAAa;AACb,uBAAa;AACb,uBAAa,OAAO,CAAC,EAAE;AACvB,sBAAY;AAMZ,cAAI,IAAI,aAAa,GAAG,SAAS;AACjC,kBAAQ,OAAO,CAAC,KAAK,OAAO,CAAC,EAAE,MAAM;AAAA,YACnC,KAAK;AAAA,YACL,KAAK;AAAA,YACL,KAAK;AACH,0BAAY;AAAA,UAChB;AAAA,QACF,WACI,cAAc,MAAM,SAAS,KAAK;AACpC,cAAI,EAAE,WAAY;AAElB,iBAAO,KAAK;AAAA,YACV,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM,CAAC,aAAa,GAAG,CAAC;AAAA,YACxB,MAAM,CAAC,UAAU,YAAY,CAAC;AAAA,YAC9B,OAAO,CAAC,WAAW,IAAI,CAAC;AAAA,UAC1B,CAAC;AAAA,QACH;AAAA,MACF;AAOA,WAAK,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AAClC,gBAAQ,OAAO,CAAC;AAChB,YAAI,MAAM,SAAS,KAAK;AAGtB,cAAI,aAAa,GAAG,OAAO,GAAG,GAAG,OAAO,CAAC;AACzC,cAAI,IAAI,EAAG;AACX,sBAAY;AACZ,cAAI,aAAa,GAAG,OAAO,GAAG,GAAG,OAAO,GAAG,CAAC;AAC5C,cAAI,IAAI,EAAG;AACX,qBAAW;AACX,cAAI,aAAa,GAAG,SAAS;AAC7B,cAAI,IAAI,EAAG;AACX,cAAI,OAAO,CAAC,EAAE,SAAS,QAAS;AAChC,qBAAW,OAAO,CAAC,EAAE;AAIrB,cAAI,aAAa,GAAG,SAAS;AAC7B,cAAI,IAAI,EAAG;AACX,cAAI,OAAO,CAAC,EAAE,SAAS,WAAY;AACnC,cAAI,OAAO,CAAC,EAAE,SAAS,SAAU;AACjC,uBAAa,OAAO,CAAC,EAAE;AAEvB,iBAAO,KAAK;AAAA,YACV,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM;AAAA,YACN,MAAM,CAAC,UAAU,YAAY,CAAC;AAAA,YAC9B,OAAO,CAAC,GAAG,IAAI,CAAC;AAAA,UAClB,CAAC;AAAA,QACH;AAAA,MACF;AAEA,aAAO,OAAO,KAAK,SAAU,GAAG,GAAG;AACjC,eAAO,EAAE,MAAM,CAAC,IAAI,EAAE,MAAM,CAAC;AAAA,MAC/B,CAAC;AAED,eAAS,aAAc,OAAO,OAAO,MAAM;AACzC,iBAASA,KAAI,QAAQ,GAAGA,MAAK,GAAGA,MAAK;AACnC,cAAI,MAAM,OAAOA,EAAC,CAAC,EAAG,QAAOA;AAC7B,cAAI,QAAQ,KAAK,OAAOA,EAAC,CAAC,EAAG,QAAO;AAAA,QACtC;AAEA,eAAO;AAAA,MACT;AAAA,IACF;AAEA,aAAS,OAAQ,MAAM;AACrB,aAAO,SAAU,OAAO;AACtB,eAAO,MAAM,SAAS,eAAe,CAAC,QAAQ,MAAM,SAAS;AAAA,MAC/D;AAAA,IACF;AAEA,aAAS,UAAW,OAAO;AACzB,aAAO,MAAM,SAAS;AAAA,IACxB;AAAA;AAAA;",
  "names": ["i"]
}
